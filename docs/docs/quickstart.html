<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Lustre - catchy tagline.</title><meta property="og:type" content="article"><meta property="og:title" content="Components"><meta property="og:url" content="https://lustre.build/docs/quickstart"><meta property="og:description" content=""><link rel="stylesheet" href="/lustre-ui.css"><link rel="stylesheet" href="/styles.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400&family=Inter:wght@300&display=swap"><script type="module" src="/app.js"></script></head><body><div class="lustre-ui-aside content-last"><div class="lustre-ui-aside"><main class="lustre-ui-box"><div class="lustre-ui-stack loose"><section class="lustre-ui-stack"><div id="quickstart" class="lustre-ui-aside align-centre"><h1>Quickstart</h1><div aria-hidden="true" class="lustre-ui-cluster"></div></div><p>Lustre is a frontend web framework for Gleam. It is primarily focused on helping
you build robust single-page applications (SPAs), but it can also be used on the
server to render static HTML. To get an idea of what it&#39;s all about, here&#39;s a
quick overview of Lustre&#39;s key features:</p><p>• Elm-inspired runtime with state management and controlled side effects out of
  the box.</p><p>• A simple, declarative API for building type-safe user interfaces.</p><p>• Stateful components built as custom elements and useable just like any other
  HTML element.</p><p>• Static HTML rendering anywhere Gleam can run: the BEAM, Node.js, Deno, or the
  browser.</p><p>In this quickstart guide we&#39;ll take a look at how to get up and running with
Lustre in both the browser and on the server.</p></section><section class="lustre-ui-stack"><div id="in-the-browser" class="lustre-ui-aside align-centre"><h2>In the browser</h2><div aria-hidden="true" class="lustre-ui-cluster"><span class="lustre-ui-tag">javascript</span></div></div><p>To get started, we&#39;ll scaffold a new Gleam project using `gleam new`. If you&#39;ve
found your way to this guide but don&#39;t already know what Gleam is you can read
about it over at <a href="https://gleam.run">gleam.run</a>.</p><pre class="lustre-ui-box"><code data-lang="shell" class="language-shell">$ gleam new lustre_quickstart &amp;&amp; cd lustre_quickstart &amp;&amp; gleam add lustre
</code></pre><p>In a real project you probably want to use a build tool like <a href="https://vitejs.dev">vite</a>
along with the <a href="https://github.com/Enderchief/vite-gleam">vite-gleam</a> plugin, but
to keep this guide simple we&#39;ll just show you what code you need to write and leave
the details on serving the app up to you. MDN have a handy guide covering some
different options to <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Tools_and_setup/set_up_a_local_testing_server">set up a local web server for development</a>
if you need some ideas.</p></section><section class="lustre-ui-stack"><div id="basic-html-setup" class="lustre-ui-aside align-centre"><h3>Basic HTML setup</h3><div aria-hidden="true" class="lustre-ui-cluster"></div></div><p>With our Gleam project scaffolded, go ahead and create an `index.html` in the root
of the project. This is the minimal code you&#39;ll typically want to get started:</p><pre class="lustre-ui-box"><code data-lang="html" class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Lustre Quickstart&lt;/title&gt;

    &lt;script type=&quot;module&quot;&gt;
      import { main } from &quot;./build/dev/javascript/lustre_quickstart/app.mjs&quot;;

      document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
        main();
      });
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div data-lustre-app&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>We wait until the DOM has loaded before calling the our app&#39;s `main` function.
This will mount the Lustre app and start rendering. We also add the `data-lustre-app`
attribute to the element we want to mount the app to. You could use a class or an
id instead, or none of that: <a href="/api/lustre#start">`lustre.start`</a> takes a CSS
selector so go wild!</p></section><section class="lustre-ui-stack"><div id="hello,-world!" class="lustre-ui-aside align-centre"><h3>Hello, world!</h3><div aria-hidden="true" class="lustre-ui-cluster"></div></div><p>Go ahead and rename the generated `lustre_quickstart.gleam` file to `app.gleam`
and replace the contents with the following:</p><pre class="lustre-ui-box"><code data-lang="gleam" class="language-gleam">import lustre
import lustre/element.{text}

pub fn main() {
  let app = lustre.element(text(&quot;Hello, world!&quot;))
  let assert Ok(_) = lustre.start(app, &quot;[data-lustre-app]&quot;, Nil)

  Nil
}
</code></pre><p>This will create a static Lustre app and mount it onto the element that matches
the CSS selector. While we&#39;re asserting everything is OK here, it is possible
for <a href="/api/lustre#start">`lustre.start`</a> to fail in a couple of ways. Check
out the docs for the <a href="/api/lustre#error-type">`lustre.Error`</a> type if you
want to know more.</p><p>Run `gleam build` and serve the HTML with your preferred static file server (this
step is necessary: JavaScript modules can&#39;t be imported when just opening a HTML
file) and admire your handiwork.</p></section><section class="lustre-ui-stack"><div id="adding-interactivity" class="lustre-ui-aside align-centre"><h3>Adding interactivity</h3><div aria-hidden="true" class="lustre-ui-cluster"></div></div><p>Now that we know how to get things up and running, let&#39;s try something a little
more exciting and add some interactivity. Replace the contents of your `app.gleam`
file with the code below and rebuild the project.</p><pre class="lustre-ui-box"><code data-lang="gleam" class="language-gleam">import gleam/int
import lustre
import lustre/element.{text}
import lustre/element/html.{div, button, p}
import lustre/event.{on_click}

pub fn main() {
  let app = lustre.simple(init, update, view)
  let assert Ok(_) = lustre.start(app, &quot;[data-lustre-app]&quot;, Nil)

  Nil
}

fn init(_) {
  0
}

type Msg {
  Incr
  Decr
}

fn update(model, msg) {
  case msg {
    Incr -&gt; model + 1
    Decr -&gt; model - 1
  }
}

fn view(model) {
  let count = int.to_string(model)

  div([], [
    button([on_click(Decr)], [text(&quot; - &quot;)]),
    p([], [text(count)]),
    button([on_click(Incr)], [text(&quot; + &quot;)])
  ])
}
</code></pre><p>You should now have a very exciting counter app! Almost every Lustre app will
boil down to the same three parts:</p><p>- A `Model` type that represents your application&#39;s state and a function to
  `init` it.
- A `Msg` type and an `update` function to update that state based on incoming
  messages.
- A `view` function that takes the current state and renders some HTML.</p><p>This architecture is not unique to Lustre. It was introduced by the Elm community
and known as the <a href="https://guide.elm-lang.org/architecture/">Elm Architecture</a>
before making its way to React as <a href="https://redux.js.org">Redux</a> and beyond, known
more generally as the Model-View-Update architecture. If you work through the
rest of our guides you&#39;ll see how this architecture helps keep side effects out
of our view code and how to create components that can encapsulate their own state
and update logic.</p><p>For now though, we&#39;ll leave things here. If you&#39;re interested in seeing how Lustre
can be used to render static HTML on the server, read on! Otherwise, you can take
this counter application as a base and start building something of your own.</p></section><section class="lustre-ui-stack"><div id="on-the-server" class="lustre-ui-aside align-centre"><h2>On the server</h2><div aria-hidden="true" class="lustre-ui-cluster"><span class="lustre-ui-tag">erlang</span><span class="lustre-ui-tag">javascript</span></div></div><p>As we&#39;ve seen, Lustre is primarily meant to be used in the browser to build
interactive SPAs. It is possible to render Lustre elements to static HTML and
simply use Lustre as a templating DSL. As before, we&#39;ll start by scaffolding a
new Gleam project and adding Lustre as a dependency:</p><pre class="lustre-ui-box"><code data-lang="shell" class="language-shell">$ gleam new lustre_quickstart &amp;&amp; cd lustre_quickstart &amp;&amp; gleam add lustre
</code></pre><p>The <a href="/api/lustre/element">`lustre/element`</a> module contains functions to
render an element as either a `String` or `StringBuilder`. Copy the following code
into `lustre_quickstart.gleam`:</p><pre class="lustre-ui-box"><code data-lang="gleam" class="language-gleam">import gleam/io
import lustre/attribute.{attribute}
import lustre/element.{text}
import lustre/element/html.{html, head, title, body, div, h1}

pub fn main() {
  html([attribute(&quot;lang&quot;, &quot;en&quot;)], [
    head([], [
     title([], [text(&quot;Lustre Quickstart&quot;)])
    ]),
    body([], [
      h1([], [text(&quot;Hello, world!&quot;)])
    ])
  ])
  |&gt; element.to_string
  |&gt; io.println
}
</code></pre><p>We can test this out by running `gleam run` and seeing the HTML printed to the
console. From here we could set up a web server using <a href="/guides/mist">Mist</a>
or <a href="/guides/wisp">Wisp</a> to serve the HTML to the browser or write it to a file
using <a href="https://hexdocs.pm/simplifile/">simplifile</a>. Because the API is the same
for both client and server rendering, it is easy to create reusable components
that can be rendered anywhere Gleam can run!</p></section><section class="lustre-ui-stack"><div id="an-example-with-wisp" class="lustre-ui-aside align-centre"><h3>An example with Wisp</h3><div aria-hidden="true" class="lustre-ui-cluster"></div></div><p>Before we go, let&#39;s just take a quick look at what it would look like to use
Lustre in a <a href="https://hexdocs.pm/wisp">Wisp</a> application. We won&#39;t scaffold out a
real app in this example, but we&#39;ll adapt one of the examples from Wisp&#39;s own
documentation.</p><p>Specifically, we&#39;ll take a look at the `show_form` function from the
<a href="https://github.com/lpil/wisp/blob/ea8a40bc20745f172695c8cc2dc0a63769f890a7/examples/2-working-with-form-data/src/app/router.gleam#L20">&quot;working with form data&quot;</a>
example:</p><pre class="lustre-ui-box"><code data-lang="gleam" class="language-gleam">...

pub fn show_form() {
  // In a larger application a template library or HTML form library might
  // be used here instead of a string literal.
  let html =
    string_builder.from_string(
      &quot;&lt;form method=&#39;post&#39;&gt;
        &lt;label&gt;Title:
          &lt;input type=&#39;text&#39; name=&#39;title&#39;&gt;
        &lt;/label&gt;
        &lt;label&gt;Name:
          &lt;input type=&#39;text&#39; name=&#39;name&#39;&gt;
        &lt;/label&gt;
        &lt;input type=&#39;submit&#39; value=&#39;Submit&#39;&gt;
      &lt;/form&gt;&quot;,
    )
  wisp.ok()
  |&gt; wisp.html_body(html)
}
</code></pre><p>They&#39;ve helpfully left a comment telling us that in a larger application we might
want to use a template library, and Lustre is up to the task! Let&#39;s refactor this
using Lustre:</p><pre class="lustre-ui-box"><code data-lang="gleam" class="language-gleam">import gleam/string
import lustre/attribute.{attribute}
import lustre/element
import lustre/element/html
...

pub fn show_form() {
  html.form([attribute(&quot;method&quot;, &quot;post&quot;)], [
    labelled_input(&quot;Title&quot;),
    labelled_input(&quot;Name&quot;),
    html.input([attribute(&quot;type&quot;, &quot;submit&quot;), attribute(&quot;value&quot;, &quot;Submit&quot;)])
  ])
  |&gt; element.to_string_builder
  |&gt; wisp.html_body
  |&gt; wisp.ok
}

fn labelled_input(name) {
  html.label([], [
    element.text(name &lt;&gt; &quot;: &quot;),
    html.input([
      attribute(&quot;type&quot;, &quot;text&quot;),
      attribute(&quot;name&quot;, string.lowercase(name))
    ])
  ])
}
</code></pre></section></div></main><div class="lustre-ui-stack lustre-ui-box"><div class="lustre-ui-stack packed"><a href="#quickstart">Quickstart</a></div><div class="lustre-ui-stack packed"><a href="#in-the-browser">In the browser</a></div><div class="lustre-ui-stack packed"><a href="#basic-html-setup">Basic HTML setup</a><a href="#hello,-world!">Hello, world!</a><a href="#adding-interactivity">Adding interactivity</a></div><div class="lustre-ui-stack packed"><a href="#on-the-server">On the server</a></div><div class="lustre-ui-stack packed"><a href="#an-example-with-wisp">An example with Wisp</a></div></div></div><div class="lustre-ui-stack lustre-ui-box loose"><h2>Lustre.</h2><nav class="lustre-ui-stack tight"><h3>Reference</h3><a href="/api/lustre">lustre</a><a href="/api/lustre/attribute">lustre/attribute</a><a href="/api/lustre/effect">lustre/effect</a><a href="/api/lustre/element">lustre/element</a><a href="/api/lustre/element/html">lustre/element/html</a><a href="/api/lustre/element/svg">lustre/element/svg</a><a href="/api/lustre/event">lustre/event</a></nav><nav class="lustre-ui-stack tight"><h3>Tutorial</h3><a href="/docs/quickstart">Quickstart</a><a href="/docs/managing-state">Managing state</a><a href="/docs/side-effects">Side effects</a><a href="/docs/server-side-rendering">Server-side rendering</a><a href="/docs/components">Components</a></nav><nav class="lustre-ui-stack tight"><h3>Guides</h3><a href="/guides/wisp">Integrating with Wisp</a></nav></div></div></body></html>